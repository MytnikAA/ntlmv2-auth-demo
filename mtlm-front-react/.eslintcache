[{"C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\index.js":"1","C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\App.js":"2","C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\reportWebVitals.js":"3","C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\ntlm.js":"4"},{"size":500,"mtime":1611728737697,"results":"5","hashOfConfig":"6"},{"size":2866,"mtime":1611830145136,"results":"7","hashOfConfig":"6"},{"size":362,"mtime":1611728737697,"results":"8","hashOfConfig":"6"},{"size":29278,"mtime":1611829110125,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"zq5a8o",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"20"},"C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\index.js",[],["21","22"],"C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\App.js",[],"C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\reportWebVitals.js",[],"C:\\Users\\maa\\test-projects\\mtlm\\mtlm-front-react\\src\\ntlm.js",["23","24","25","26","27","28","29"],"// NTLM (ntlm.js) authentication in JavaScript.\n// ------------------------------------------------------------------------\n// The MIT License (MIT). Copyright (c) 2012 Erland Ranvinge.\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nclass Msg {\n\n    constructor(data) {\n        this.data = [];\n        if (!data) return;\n        if (data.indexOf('NTLM ') == 0) data = data.substr(5);\n        atob(data).split('').map(function (c) {\n            this.push(c.charCodeAt(0));\n        }, this.data);\n    }\n\n    addByte(b) {\n        this.data.push(b);\n    }\n\n    addShort(s) {\n        this.data.push(s & 0xFF);\n        this.data.push((s >> 8) & 0xFF);\n    }\n\n    addString(str, utf16) {\n        if (utf16) // Fake UTF16 by padding each character in string.\n            str = str.split('').map(function (c) {\n                return (c + '\\0');\n            }).join('');\n\n        for (let i = 0; i < str.length; i++)\n            this.data.push(str.charCodeAt(i));\n    }\n\n    getString(offset, length) {\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            if (offset + i >= this.data.length)\n                return '';\n            result += String.fromCharCode(this.data[offset + i]);\n        }\n        return result;\n    }\n\n    getByte(offset) {\n        return this.data[offset];\n    }\n\n    toBase64() {\n        const str = String.fromCharCode.apply(null, this.data);\n        return btoa(str).replace(/.{76}(?=.)/g, '$&');\n    }\n}\n\nexport function createMessage1(hostname, domain) {\n    const msg1 = new Msg();\n    msg1.addString('NTLMSSP\\0');\n    msg1.addByte(1);\n    msg1.addString('\\0\\0\\0');\n    msg1.addShort(0xb203);\n    msg1.addString('\\0\\0');\n    msg1.addShort(domain.length);\n    msg1.addShort(domain.length);\n    msg1.addShort(32 + hostname.length);\n    msg1.addString('\\0\\0');\n    msg1.addShort(hostname.length);\n    msg1.addShort(hostname.length);\n    msg1.addShort(32);\n    msg1.addString('\\0\\0');\n    msg1.addString(hostname.toUpperCase());\n    msg1.addString(domain.toUpperCase());\n    return msg1;\n}\n\nexport function getChallenge(data) {\n    const msg2 = new Msg(data);\n    if (msg2.getString(0, 8) !== 'NTLMSSP\\0') {\n        throw new Error('Invalid NTLM response header.');\n    }\n    if (msg2.getByte(8) !== 2) {\n        throw new Error('Invalid NTLM response type.');\n    }\n    return msg2.getString(24, 8);\n}\n\nexport function createMessage3(challenge, domain, username, password, hostname) {\n    let ntlmHashes = getNTLMHashes(domain, username, password);\n    const lmResponse = buildResponse(ntlmHashes.lmHashedPassword, challenge);\n    const ntResponse = buildResponse(ntlmHashes.ntHashedPassword, challenge);\n    const msg3 = new Msg();\n\n    msg3.addString('NTLMSSP\\0');\n    msg3.addByte(3);\n    msg3.addString('\\0\\0\\0');\n\n    msg3.addShort(24); // lmResponse\n    msg3.addShort(24);\n    msg3.addShort(64 + (domain.length + username.length + hostname.length) * 2);\n    msg3.addString('\\0\\0');\n\n    msg3.addShort(24); // ntResponse\n    msg3.addShort(24);\n    msg3.addShort(88 + (domain.length + username.length + hostname.length) * 2);\n    msg3.addString('\\0\\0');\n\n    msg3.addShort(domain.length * 2); // Domain.\n    msg3.addShort(domain.length * 2);\n    msg3.addShort(64);\n    msg3.addString('\\0\\0');\n\n    msg3.addShort(username.length * 2); // Username.\n    msg3.addShort(username.length * 2);\n    msg3.addShort(64 + domain.length * 2);\n    msg3.addShort('\\0\\0');\n\n    msg3.addShort(hostname.length * 2); // Hostname.\n    msg3.addShort(hostname.length * 2);\n    msg3.addShort(64 + (domain.length + username.length) * 2);\n    msg3.addString('\\0\\0');\n\n    msg3.addString('\\0\\0\\0\\0');\n    msg3.addShort(112 + (domain.length + username.length + hostname.length) * 2);\n    msg3.addString('\\0\\0');\n    msg3.addShort(0x8201);\n    msg3.addString('\\0\\0');\n\n    msg3.addString(domain.toUpperCase(), true); // \"Some\" string are passed as UTF-16.\n    msg3.addString(username, true);\n    msg3.addString(hostname.toUpperCase(), true);\n    msg3.addString(lmResponse);\n    msg3.addString(ntResponse);\n\n    return msg3;\n}\n\nfunction createKey(str) {\n    const key56 = [];\n    while (str.length < 7) str += '\\0';\n    str = str.substr(0, 7);\n    str.split('').map(function (c) {\n        this.push(c.charCodeAt(0));\n    }, key56);\n    var key = [0, 0, 0, 0, 0, 0, 0, 0];\n    key[0] = key56[0]; // Convert 56 bit key to 64 bit.\n    key[1] = ((key56[0] << 7) & 0xFF) | (key56[1] >> 1);\n    key[2] = ((key56[1] << 6) & 0xFF) | (key56[2] >> 2);\n    key[3] = ((key56[2] << 5) & 0xFF) | (key56[3] >> 3);\n    key[4] = ((key56[3] << 4) & 0xFF) | (key56[4] >> 4);\n    key[5] = ((key56[4] << 3) & 0xFF) | (key56[5] >> 5);\n    key[6] = ((key56[5] << 2) & 0xFF) | (key56[6] >> 6);\n    key[7] = (key56[6] << 1) & 0xFF;\n    for (let i = 0; i < key.length; i++) { // Fix DES key parity bits.\n        let bit = 0;\n        for (var k = 0; k < 7; k++) {\n            const t = key[i] >> k;\n            bit = (t ^ bit) & 0x1;\n        }\n        key[i] = (key[i] & 0xFE) | bit;\n    }\n\n    let result = '';\n    key.map(function (i) {\n        result += String.fromCharCode(i);\n    });\n    return result;\n}\n\nfunction buildResponse(key, text) {\n    while (key.length < 21)\n        key += '\\0';\n    const key1 = createKey(key.substr(0, 7));\n    const key2 = createKey(key.substr(7, 7));\n    const key3 = createKey(key.substr(14, 7));\n    return des(key1, text, 1, 0) + des(key2, text, 1, 0) + des(key3, text, 1, 0);\n}\n\nfunction getNTLMHashes(domain, username, password) {\n    const magic = 'KGS!@#$%'; // Create LM password hash.\n    let lmPassword = password.toUpperCase().substr(0, 14);\n    while (lmPassword.length < 14) lmPassword += '\\0';\n    const key1 = createKey(lmPassword);\n    const key2 = createKey(lmPassword.substr(7));\n    const lmHashedPassword = des(key1, magic, 1, 0) + des(key2, magic, 1, 0);\n\n    let ntPassword = ''; // Create NT password hash.\n    for (var i = 0; i < password.length; i++)\n        ntPassword += password.charAt(i) + '\\0';\n    const ntHashedPassword = str_md4(ntPassword);\n    return {\n        lmHashedPassword: lmHashedPassword,\n        ntHashedPassword: ntHashedPassword\n    };\n}\n\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD4 Message\n * Digest Algorithm, as defined in RFC 1320.\n * Version 2.1 Copyright (C) Jerrad Pierce, Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\nvar chrsz = 8;\n\nfunction str_md4(s) {\n    return binl2str(core_md4(str2binl(s), s.length * chrsz));\n}\n\nfunction core_md4(x, len) {\n    x[len >> 5] |= 0x80 << (len % 32);\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n\n    for (let i = 0; i < x.length; i += 16) {\n        const olda = a;\n        const oldb = b;\n        const oldc = c;\n        const oldd = d;\n\n        a = md4_ff(a, b, c, d, x[i + 0], 3);\n        d = md4_ff(d, a, b, c, x[i + 1], 7);\n        c = md4_ff(c, d, a, b, x[i + 2], 11);\n        b = md4_ff(b, c, d, a, x[i + 3], 19);\n        a = md4_ff(a, b, c, d, x[i + 4], 3);\n        d = md4_ff(d, a, b, c, x[i + 5], 7);\n        c = md4_ff(c, d, a, b, x[i + 6], 11);\n        b = md4_ff(b, c, d, a, x[i + 7], 19);\n        a = md4_ff(a, b, c, d, x[i + 8], 3);\n        d = md4_ff(d, a, b, c, x[i + 9], 7);\n        c = md4_ff(c, d, a, b, x[i + 10], 11);\n        b = md4_ff(b, c, d, a, x[i + 11], 19);\n        a = md4_ff(a, b, c, d, x[i + 12], 3);\n        d = md4_ff(d, a, b, c, x[i + 13], 7);\n        c = md4_ff(c, d, a, b, x[i + 14], 11);\n        b = md4_ff(b, c, d, a, x[i + 15], 19);\n\n        a = md4_gg(a, b, c, d, x[i + 0], 3);\n        d = md4_gg(d, a, b, c, x[i + 4], 5);\n        c = md4_gg(c, d, a, b, x[i + 8], 9);\n        b = md4_gg(b, c, d, a, x[i + 12], 13);\n        a = md4_gg(a, b, c, d, x[i + 1], 3);\n        d = md4_gg(d, a, b, c, x[i + 5], 5);\n        c = md4_gg(c, d, a, b, x[i + 9], 9);\n        b = md4_gg(b, c, d, a, x[i + 13], 13);\n        a = md4_gg(a, b, c, d, x[i + 2], 3);\n        d = md4_gg(d, a, b, c, x[i + 6], 5);\n        c = md4_gg(c, d, a, b, x[i + 10], 9);\n        b = md4_gg(b, c, d, a, x[i + 14], 13);\n        a = md4_gg(a, b, c, d, x[i + 3], 3);\n        d = md4_gg(d, a, b, c, x[i + 7], 5);\n        c = md4_gg(c, d, a, b, x[i + 11], 9);\n        b = md4_gg(b, c, d, a, x[i + 15], 13);\n\n        a = md4_hh(a, b, c, d, x[i + 0], 3);\n        d = md4_hh(d, a, b, c, x[i + 8], 9);\n        c = md4_hh(c, d, a, b, x[i + 4], 11);\n        b = md4_hh(b, c, d, a, x[i + 12], 15);\n        a = md4_hh(a, b, c, d, x[i + 2], 3);\n        d = md4_hh(d, a, b, c, x[i + 10], 9);\n        c = md4_hh(c, d, a, b, x[i + 6], 11);\n        b = md4_hh(b, c, d, a, x[i + 14], 15);\n        a = md4_hh(a, b, c, d, x[i + 1], 3);\n        d = md4_hh(d, a, b, c, x[i + 9], 9);\n        c = md4_hh(c, d, a, b, x[i + 5], 11);\n        b = md4_hh(b, c, d, a, x[i + 13], 15);\n        a = md4_hh(a, b, c, d, x[i + 3], 3);\n        d = md4_hh(d, a, b, c, x[i + 11], 9);\n        c = md4_hh(c, d, a, b, x[i + 7], 11);\n        b = md4_hh(b, c, d, a, x[i + 15], 15);\n\n        a = safe_add(a, olda);\n        b = safe_add(b, oldb);\n        c = safe_add(c, oldc);\n        d = safe_add(d, oldd);\n\n    }\n    return Array(a, b, c, d);\n}\n\nfunction md4_cmn(q, a, b, x, s, t) {\n    return safe_add(rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n}\n\nfunction md4_ff(a, b, c, d, x, s) {\n    return md4_cmn((b & c) | ((~b) & d), a, 0, x, s, 0);\n}\n\nfunction md4_gg(a, b, c, d, x, s) {\n    return md4_cmn((b & c) | (b & d) | (c & d), a, 0, x, s, 1518500249);\n}\n\nfunction md4_hh(a, b, c, d, x, s) {\n    return md4_cmn(b ^ c ^ d, a, 0, x, s, 1859775393);\n}\n\nfunction safe_add(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n}\n\nfunction rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n\nfunction str2binl(str) {\n    const bin = Array();\n    const mask = (1 << chrsz) - 1;\n    for (var i = 0; i < str.length * chrsz; i += chrsz)\n        bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (i % 32);\n    return bin;\n}\n\nfunction binl2str(bin) {\n    let str = \"\";\n    const mask = (1 << chrsz) - 1;\n    for (var i = 0; i < bin.length * 32; i += chrsz)\n        str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & mask);\n    return str;\n}\n\n//Paul Tero, July 2001\n//http://www.tero.co.uk/des/\n//\n//Optimised for performance with large blocks by Michael Hayworth, November 2001\n//http://www.netdealing.com\n//\n//THIS SOFTWARE IS PROVIDED \"AS IS\" AND\n//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n//ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n//FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n//DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n//OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n//HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n//LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n//OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n//SUCH DAMAGE.\n\n//des\n//this takes the key, the message, and whether to encrypt or decrypt\nfunction des(key, message, encrypt, mode, iv, padding) {\n    //declaring this locally speeds things up a bit\n    const spfunction1 = [0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004];\n    const spfunction2 = [-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000];\n    const spfunction3 = [0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200];\n    const spfunction4 = [0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080];\n    const spfunction5 = [0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100];\n    const spfunction6 = [0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010];\n    const spfunction7 = [0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002];\n    const spfunction8 = [0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000];\n\n    //create the 16 or 48 subkeys we will need\n    let keys = des_createKeys(key);\n    let m = 0, i, j, temp, temp2, right1, right2, left, right, looping;\n    let cbcleft, cbcleft2, cbcright, cbcright2\n    let endloop, loopinc;\n    let len = message.length;\n    let chunk = 0;\n    //set up the loops for single and triple des\n    const iterations = keys.length === 32 ? 3 : 9; //single or triple des\n    if (iterations === 3) {\n        looping = encrypt ? [0, 32, 2] : [30, -2, -2];\n    } else {\n        looping = encrypt ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2];\n    }\n\n    //pad the message depending on the padding parameter\n    if (padding === 2) message += \"        \"; //pad the message with spaces\n    else if (padding === 1) {\n        temp = 8 - (len % 8);\n        message += String.fromCharCode(temp, temp, temp, temp, temp, temp, temp, temp);\n        if (temp === 8) len += 8;\n    } //PKCS7 padding\n    else if (!padding) message += \"\\0\\0\\0\\0\\0\\0\\0\\0\"; //pad the message out with null bytes\n\n    //store the result here\n    let result = \"\";\n    let tempresult = \"\";\n\n    if (mode === 1) { //CBC mode\n        cbcleft = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);\n        cbcright = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);\n        m = 0;\n    }\n\n    //loop through each 64 bit chunk of the message\n    while (m < len) {\n        left = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);\n        right = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);\n\n        //for Cipher Block Chaining mode, xor the message with the previous result\n        if (mode === 1) {\n            if (encrypt) {\n                left ^= cbcleft;\n                right ^= cbcright;\n            } else {\n                cbcleft2 = cbcleft;\n                cbcright2 = cbcright;\n                cbcleft = left;\n                cbcright = right;\n            }\n        }\n\n        //first each 64 but chunk of the message must be permuted according to IP\n        temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\n        right ^= temp;\n        left ^= (temp << 4);\n        temp = ((left >>> 16) ^ right) & 0x0000ffff;\n        right ^= temp;\n        left ^= (temp << 16);\n        temp = ((right >>> 2) ^ left) & 0x33333333;\n        left ^= temp;\n        right ^= (temp << 2);\n        temp = ((right >>> 8) ^ left) & 0x00ff00ff;\n        left ^= temp;\n        right ^= (temp << 8);\n        temp = ((left >>> 1) ^ right) & 0x55555555;\n        right ^= temp;\n        left ^= (temp << 1);\n\n        left = ((left << 1) | (left >>> 31));\n        right = ((right << 1) | (right >>> 31));\n\n        //do this either 1 or 3 times for each chunk of the message\n        for (j = 0; j < iterations; j += 3) {\n            endloop = looping[j + 1];\n            loopinc = looping[j + 2];\n            //now go through and perform the encryption or decryption\n            for (i = looping[j]; i !== endloop; i += loopinc) { //for efficiency\n                right1 = right ^ keys[i];\n                right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];\n                //the result is attained by passing these bytes through the S selection functions\n                temp = left;\n                left = right;\n                right = temp ^ (spfunction2[(right1 >>> 24) & 0x3f] | spfunction4[(right1 >>> 16) & 0x3f]\n                    | spfunction6[(right1 >>> 8) & 0x3f] | spfunction8[right1 & 0x3f]\n                    | spfunction1[(right2 >>> 24) & 0x3f] | spfunction3[(right2 >>> 16) & 0x3f]\n                    | spfunction5[(right2 >>> 8) & 0x3f] | spfunction7[right2 & 0x3f]);\n            }\n            temp = left;\n            left = right;\n            right = temp; //unreverse left and right\n        } //for either 1 or 3 iterations\n\n        //move then each one bit to the right\n        left = ((left >>> 1) | (left << 31));\n        right = ((right >>> 1) | (right << 31));\n\n        //now perform IP-1, which is IP in the opposite direction\n        temp = ((left >>> 1) ^ right) & 0x55555555;\n        right ^= temp;\n        left ^= (temp << 1);\n        temp = ((right >>> 8) ^ left) & 0x00ff00ff;\n        left ^= temp;\n        right ^= (temp << 8);\n        temp = ((right >>> 2) ^ left) & 0x33333333;\n        left ^= temp;\n        right ^= (temp << 2);\n        temp = ((left >>> 16) ^ right) & 0x0000ffff;\n        right ^= temp;\n        left ^= (temp << 16);\n        temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\n        right ^= temp;\n        left ^= (temp << 4);\n\n        //for Cipher Block Chaining mode, xor the message with the previous result\n        if (mode === 1) {\n            if (encrypt) {\n                cbcleft = left;\n                cbcright = right;\n            } else {\n                left ^= cbcleft2;\n                right ^= cbcright2;\n            }\n        }\n        tempresult += String.fromCharCode((left >>> 24), ((left >>> 16) & 0xff), ((left >>> 8) & 0xff), (left & 0xff), (right >>> 24), ((right >>> 16) & 0xff), ((right >>> 8) & 0xff), (right & 0xff));\n\n        chunk += 8;\n        if (chunk === 512) {\n            result += tempresult;\n            tempresult = \"\";\n            chunk = 0;\n        }\n    } //for every 8 characters, or 64 bits in the message\n\n    //return the result as an array\n    return result + tempresult;\n} //end of des\n\n\n//des_createKeys\n//this takes as input a 64 bit key (even though only 56 bits are used)\n//as an array of 2 integers, and returns 16 48 bit keys\nfunction des_createKeys(key) {\n    //declaring this locally speeds things up a bit\n    let pc2bytes0 = [0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204];\n    let pc2bytes1 = [0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101];\n    let pc2bytes2 = [0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808];\n    let pc2bytes3 = [0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000];\n    let pc2bytes4 = [0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010];\n    let pc2bytes5 = [0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420];\n    let pc2bytes6 = [0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002];\n    let pc2bytes7 = [0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800];\n    let pc2bytes8 = [0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002];\n    let pc2bytes9 = [0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408];\n    let pc2bytes10 = [0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020];\n    let pc2bytes11 = [0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200];\n    let pc2bytes12 = [0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010];\n    let pc2bytes13 = [0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105];\n\n    //how many iterations (1 for des, 3 for triple des)\n    const iterations = key.length > 8 ? 3 : 1; //changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys\n    //stores the return keys\n    const keys = new Array(32 * iterations);\n    //now define the left shifts which need to be done\n    const shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];\n    //other variables\n    let lefttemp, righttemp, m = 0, n = 0, temp;\n\n    for (let j = 0; j < iterations; j++) { //either 1 or 3 iterations\n        let left = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);\n        let right = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);\n\n        temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;\n        right ^= temp;\n        left ^= (temp << 4);\n        temp = ((right >>> -16) ^ left) & 0x0000ffff;\n        left ^= temp;\n        right ^= (temp << -16);\n        temp = ((left >>> 2) ^ right) & 0x33333333;\n        right ^= temp;\n        left ^= (temp << 2);\n        temp = ((right >>> -16) ^ left) & 0x0000ffff;\n        left ^= temp;\n        right ^= (temp << -16);\n        temp = ((left >>> 1) ^ right) & 0x55555555;\n        right ^= temp;\n        left ^= (temp << 1);\n        temp = ((right >>> 8) ^ left) & 0x00ff00ff;\n        left ^= temp;\n        right ^= (temp << 8);\n        temp = ((left >>> 1) ^ right) & 0x55555555;\n        right ^= temp;\n        left ^= (temp << 1);\n\n        //the right side needs to be shifted and to get the last four bits of the left side\n        temp = (left << 8) | ((right >>> 20) & 0x000000f0);\n        //left needs to be put upside down\n        left = (right << 24) | ((right << 8) & 0xff0000) | ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0);\n        right = temp;\n\n        //now go through and perform these shifts on the left and right keys\n        for (let i = 0; i < shifts.length; i++) {\n            //shift the keys either one or two bits to the left\n            if (shifts[i]) {\n                left = (left << 2) | (left >>> 26);\n                right = (right << 2) | (right >>> 26);\n            } else {\n                left = (left << 1) | (left >>> 27);\n                right = (right << 1) | (right >>> 27);\n            }\n            left &= -0xf;\n            right &= -0xf;\n\n            //now apply PC-2, in such a way that E is easier when encrypting or decrypting\n            //this conversion will look like PC-2 except only the last 6 bits of each byte are used\n            //rather than 48 consecutive bits and the order of lines will be according to\n            //how the S selection functions will be applied: S2, S4, S6, S8, S1, S3, S5, S7\n            lefttemp = pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf]\n                | pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf]\n                | pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf]\n                | pc2bytes6[(left >>> 4) & 0xf];\n            righttemp = pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf]\n                | pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf]\n                | pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf]\n                | pc2bytes13[(right >>> 4) & 0xf];\n            temp = ((righttemp >>> 16) ^ lefttemp) & 0x0000ffff;\n            keys[n++] = lefttemp ^ temp;\n            keys[n++] = righttemp ^ (temp << 16);\n        }\n    } //for each iterations\n    //return the keys we've created\n    return keys;\n} //end of des_createKeys\n",["30","31"],{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","severity":1,"message":"37","line":26,"column":35,"nodeType":"38","messageId":"39","endLine":26,"endColumn":37},{"ruleId":"40","severity":1,"message":"41","line":27,"column":34,"nodeType":"42","messageId":"43","endLine":27,"endColumn":43},{"ruleId":"40","severity":1,"message":"41","line":156,"column":23,"nodeType":"42","messageId":"43","endLine":156,"endColumn":32},{"ruleId":"40","severity":1,"message":"41","line":178,"column":13,"nodeType":"42","messageId":"43","endLine":178,"endColumn":22},{"ruleId":"44","severity":1,"message":"45","line":298,"column":12,"nodeType":"46","messageId":"47","endLine":298,"endColumn":29},{"ruleId":"44","severity":1,"message":"45","line":328,"column":17,"nodeType":"46","messageId":"47","endLine":328,"endColumn":24},{"ruleId":"48","severity":1,"message":"49","line":376,"column":28,"nodeType":"50","messageId":"51","endLine":376,"endColumn":33},{"ruleId":"32","replacedBy":"52"},{"ruleId":"34","replacedBy":"53"},"no-native-reassign",["54"],"no-negated-in-lhs",["55"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","array-callback-return","Array.prototype.map() expects a return value from function.","FunctionExpression","expectedInside","no-array-constructor","The array literal notation [] is preferable.","CallExpression","preferLiteral","no-unused-vars","'temp2' is defined but never used.","Identifier","unusedVar",["54"],["55"],"no-global-assign","no-unsafe-negation"]